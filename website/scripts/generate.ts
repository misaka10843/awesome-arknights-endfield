import { readFileSync, writeFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { resolve } from 'node:path';
import chalk from 'chalk';
import { filterValidProjects, sortProjectsById } from '@/helpers';
import { CATEGORY_LABEL, LANGUAGES, WEBSITE_PROVIDER_LABEL } from '@/shared';
import type { Category, Language, Project } from '@/shared';

/**
 * @description Slugify a string, based on https://github.com/yzhang-gh/vscode-markdown/blob/master/src/util/slugify.ts
 * @see https://github.com/yzhang-gh/vscode-markdown
 * @license MIT
 */
function slugify(text: string): string {
  /**
   * The definition of punctuation from GitHub and GitLab.
   *
   * Converted from Ruby regular expression `/[^\p{Word}\- ]/u`
   * `\p{Word}` => Letter (Ll/Lm/Lo/Lt/Lu), Mark (Mc/Me/Mn), Number (Nd/Nl), Connector_Punctuation (Pc)
   * It's weird that Ruby's `\p{Word}` actually does not include Category No.
   * https://ruby-doc.org/core/Regexp.html
   * https://rubular.com/r/ThqXAm370XRMz6
   */
  const REGEXP_GITHUB_PUNCTUATION = /[^\p{L}\p{M}\p{Nd}\p{Nl}\p{Pc}\- ]/gu;

  // According to an inspection in 2020-12, GitHub passes the raw content as is,
  // and does not trim leading or trailing C0, Zs characters in any step.
  // <https://github.com/jch/html-pipeline/blob/master/lib/html/pipeline/toc_filter.rb>
  return text
    .replace(REGEXP_GITHUB_PUNCTUATION, '')
    .toLowerCase() // According to an inspection in 2020-09, GitHub performs full Unicode case conversion now.
    .replace(/ /g, '-');
}

/////////////////////////////////// Builder ///////////////////////////////////

const LINE_BREAK = '\n';

function generateLink(href: string, text: string) {
  return `[${text}](${href})`;
}

function generateBanner() {
  const BANNER = `<!--
  DO NOT EDIT THIS FILE DIRECTLY
  Generated by scripts/generate.ts
-->
`;
  return BANNER;
}

function generateHeading(title: string, level: number = 2) {
  const hashtag = Math.min(Math.max(level, 1), 6);
  return String.prototype.concat(`${'#'.repeat(hashtag)} ${title}`, LINE_BREAK);
}

function generateToc(headers: Array<string>) {
  return headers
    .map((header) => `- [${header}](#${slugify(header).toLowerCase()})`)
    .join(LINE_BREAK)
    .concat(LINE_BREAK);
}

function generateProject(lang: Language, project: Project) {
  const blocks: Array<string> = [];

  const name = project.repository
    ? generateLink(project.repository, project.name)
    : project.name;

  if (project.website) {
    for (const { url, provider } of project.website) {
      blocks.push(generateLink(url, WEBSITE_PROVIDER_LABEL[provider][lang]));
    }
  }

  const description = project.description[lang];
  blocks.push(description);

  return [`- ${name}`, ...blocks.map((b) => `  - ${b}`), LINE_BREAK].join(LINE_BREAK);
}

/////////////////////////////////// Update ///////////////////////////////////

const PROJECT_ROOT = resolve(process.cwd(), '../');

function generateFileName(lang: Language, prefix: string) {
  return lang === 'en-US' ? `${prefix}.md` : `${prefix}.${lang}.md`;
}

const LIST_MAP = LANGUAGES.reduce(
  (acc, lang) => ({
    ...acc,
    [lang]: generateFileName(lang, 'LIST'),
  }),
  {} as Record<Language, string>
);

const README_MAP = LANGUAGES.reduce(
  (acc, lang) => ({
    ...acc,
    [lang]: generateFileName(lang, 'README'),
  }),
  {} as Record<Language, string>
);

function generateBadge(count: number, text: string) {
  return `<img src="https://img.shields.io/badge/${text}-${count}-blue" alt="${text}" />`;
}

function updateReadmeBadge(lang: Language, count: number) {
  const BADGE_REGEX = /<!-- BADGE_COUNT_START -->[\s\S]*?<!-- BADGE_COUNT_END -->/;

  const fileName = README_MAP[lang];
  const readmeFile = resolve(PROJECT_ROOT, fileName);

  console.info(chalk.bold.blue('> Updating badge count...'));
  console.info(chalk.dim(`  File: ${fileName}`));
  console.info(chalk.dim(`  Count: ${count}`));

  let content = readFileSync(readmeFile, 'utf-8');

  // Replace content between BADGE_COUNT_START and BADGE_COUNT_END
  if (BADGE_REGEX.test(content)) {
    const badgeLine = generateBadge(count, 'Projects');
    content = content.replace(
      BADGE_REGEX,
      `<!-- BADGE_COUNT_START -->\n  ${badgeLine}\n  <!-- BADGE_COUNT_END -->`
    );

    writeFileSync(readmeFile, content, 'utf-8');
    console.info(chalk.green('✓ Badge count updated successfully\n'));
  } else {
    console.error(chalk.yellow('⚠ Badge markers not found\n'));
  }
}

function updateReadmeRecentProjects(lang: Language, projects: Array<Project>) {
  const RECENT_REGEX = /<!-- RECENT_START -->[\s\S]*?<!-- RECENT_END -->/;

  const fileName = README_MAP[lang];
  const readmeFile = resolve(PROJECT_ROOT, fileName);

  console.info(chalk.bold.blue('> Updating recent projects...'));
  console.info(chalk.dim(`  File: ${fileName}`));
  console.info(chalk.dim(`  Projects: ${projects.length}`));

  let content = readFileSync(readmeFile, 'utf-8');

  // Generate recent projects section
  const recentSection = projects
    .map((project) => generateProject(lang, project))
    .join('');

  // Replace content between RECENT_START and RECENT_END
  if (RECENT_REGEX.test(content)) {
    content = content.replace(
      RECENT_REGEX,
      `<!-- RECENT_START -->\n${recentSection.trim()}\n<!-- RECENT_END -->`
    );

    writeFileSync(readmeFile, content, 'utf-8');
    console.info(chalk.green('✓ Recent projects updated successfully\n'));
  } else {
    console.error(chalk.yellow('⚠ Recent markers not found\n'));
  }
}

function generateList(lang: Language, projects: Array<Project>) {
  console.info(chalk.bold.blue('> Generating list...'));
  console.info(chalk.dim(`  Language: ${lang}`));

  let doc = generateBanner();
  doc += LINE_BREAK;

  const groups = projects.reduce(
    (acc, project) => {
      const category = project.category;
      if (!acc[category]) {
        acc[category] = [];
      }
      acc[category].push(project);
      return acc;
    },
    {} as Record<Category, Array<Project>>
  );

  doc += generateToc(
    Object.keys(groups).map((category) => CATEGORY_LABEL[category as Category][lang])
  );
  doc += LINE_BREAK;

  for (const [category, projects] of Object.entries(groups)) {
    doc += generateHeading(CATEGORY_LABEL[category as Category][lang]);
    doc += LINE_BREAK;

    projects.forEach((project) => {
      doc += generateProject(lang, project);
    });
  }

  // Remove trailing newline
  doc = doc.trimEnd() + LINE_BREAK;

  const fileName = LIST_MAP[lang];
  const outputFile = resolve(PROJECT_ROOT, fileName);

  writeFileSync(outputFile, doc, 'utf-8');

  console.info(chalk.green('✓ List generated successfully\n'));
}

const RECENT_COUNT = 5;

const DEFAULT_PATH = fileURLToPath(new URL('../../data/LIST.json', import.meta.url));

function main() {
  console.info(chalk.bold.blue('> Loading data...'));
  console.info(chalk.dim(`  File path: ${DEFAULT_PATH}`));
  const fileContent = readFileSync(DEFAULT_PATH, 'utf-8');
  const data = JSON.parse(fileContent);
  const validProjects = filterValidProjects(data as Array<Project>);
  const sortedProjects = sortProjectsById(validProjects);
  console.info(chalk.dim(`  Valid projects: ${validProjects.length}`));
  console.info(chalk.green('✓ Data loaded successfully\n'));

  for (const lang of LANGUAGES) {
    generateList(lang, sortedProjects);
    updateReadmeBadge(lang, validProjects.length);
    updateReadmeRecentProjects(lang, sortedProjects.slice(-RECENT_COUNT));
  }

  console.info(chalk.bold.green('✓ All generation stages passed'));
}

main();
